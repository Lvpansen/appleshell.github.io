---
title: 前端面试题
date: 2020-02-26 00:28:21
tags: 面试
---

记录一篇面试相关的文章，这样就不用每次都要去搜面试相关的内容了。

<!-- more -->

[前端综合面试题][1]，面试题的分类可以按照这篇文章来，具体的面试题，尤其是原理部分的，由于工作中用不到，死记硬背很快就会忘（当然明天就要面试还是要的）。原理部分就多看多理解，实践部分的内容就一定要动手敲，眼高手低，只会是眼睛懂了，剩下都没懂。

[面经大全][2]，包含了众多的面试文章，包括面试题和面试文章。

## css

css样式表的分类和优先级、css选择器、盒模型、定位、布局、flex、Grid、媒体查询、动画、css文件在浏览器中的加载

[css面试题1][3]，答案可能有问题，自己去官方资料中找答案。
[css面试题2][7]

css的大部分知识点是需要记和背的，但最重要的是在项目中使用，才能做到掌握。因为css是跟页面显示效果有关的，只有实践了，才能真正立即每个属性的含义。

## js

[js原生知识面试题1][13]

### 概念性知识

1. 考查知识点：原型

    ```js
    function Person(name) {
      this.name = name
    }
    let p = new Person('Tom')
    ```

    问题1：`p.__protp__`等于什么------------Person.prototype

    问题2：`Person.protytype`等于什么------------Function.prototype

    要记住的知识点：

    * prototype属性是个对象，是函数才拥有的属性，声明函数时这个属性被自动创建。
    * 实例的__proto__属性（原型）等于其构造函数的prototype属性。
    * 原型链是通过__proto__属性形成的。
    * 函数都是由new Function()创建的。
    * 原型链的终点是Object.prototype。Object.prototype.__proto__是null。
    * 更详细的内容看[这篇文章][4]


    再看看这道题目：

      ```js
      var foo = {},
      F = function(){};
      Object.prototype.a = 'value a';
      Function.prototype.b = 'value b';

      console.log(foo.a)   
      console.log(foo.b)    
      console.log(F.a)      
      console.log(F.b)  
      ```

2. new 操作符都干了啥。构造函数没有返回值，显示返回一个对象，显示返回非对象类型的值三种情况的区别。

3. 以下代码输出啥
  ```js
  function Foo() {
    getName = function () { alert (1); };
    return this;
  }
  Foo.getName = function () { alert (2);};
  Foo.prototype.getName = function () { alert (3);};
  var getName = function () { alert (4);};
  function getName() { alert (5);}
  
  //请写出以下输出结果：
  Foo.getName();
  getName();
  Foo().getName();
  getName();
  new Foo.getName();
  new Foo().getName();
  new new Foo().getName();
  ```
  答案请看：[这里]:[5]


4. 正向代理和反向代理

正向代理：翻墙访问国外网站就是正向代理的例子，正向代理服务器Apache。用户访问的是目标网站的地址
反向代理：使用nginx解决跨域问题，用户访问的是nginx这个Web服务器的地址。

5. js事件循环

这里面涉及到知识点比较多：宏任务和微任务的概念，事件循环执行机制，Promise，async/await。

参考[这篇文章][6]，这篇文章里难理解的点是async/await执行顺序，await会产生一个微任务（Promise.then也是微任务），主要理解产生这个微任务的时机。新版本的chorme执行顺序有所不同，需要理解和记忆。


6. ajax原理，手写实现。

7. 闭包

8. 作用域

9. js数据类型和类型转换（包括隐式转换）

10. 防抖和节流

    防抖和节流都是为了防止函数的频繁多次执行。两者的区别是，当用户一直触发一个函数，且触发函数的间隔小于设置的时间，防抖只会执行一次，节流会每隔一段时间执行一次。

11. [] == ![]，返回值是什么？

    考察点：`==`的类型转换规则，运算符优先级（`!`优先级高于`==`）

    1. 首先判断两者类型是否相同，如果相等，判断值是否相等.
    2. 如果类型不同，进行类型转换
    3. 判断比较的是否是 null 或者是 undefined, 如果是, 返回 true .
    4. 判断两者类型是否为 string 和 number, 如果是, 将字符串转换成 number
    5. 判断其中一方是否为 boolean, 如果是, 将 boolean 转为 number 再进行判断
    6. 判断其中一方是否为 object 且另一方为 string、number 或者 symbol , 如果是, 将 object 转为原始类型再进行判断
    7. 要注意的是两方都是复杂数据类型，比较的是引用地址。`[] == []`返回值是false。

12. call实现的原理，[参考这里](https://segmentfault.com/a/1190000018799827#item-0-15)

    call函数中的this指向的是调用call的函数。

    在传入的对象上调用函数，使得调用函数的this指向传入的对象。

    ```js
    Function.prototype.my_call = function(context, ...rest) {
      if(!context) {
        context = window === 'undefined' ? global : window;
      }

      context.fn = this; // this指向的是调用call的函数。例如Array.push.call(obj, 1, 2), this指向的就是Array.push函数。
      let args = rest; // 获取除了this指向对象之外的参数
      let result = context.fn(...rest)  //fn是调用call的函数，fn中的this指向context，实现改变this指向的功能。
      delete context.fn
      return result
    }
    ```

    apply实现原理和call一样，只有第二个参数不同，是个数组。

    bind和call/apply的一个重要区别是：一个函数通过call/apply调用时，会直接调用执行。而bind会创建一个新函数，这个新函数被调用时，bind()的第一个参数就是它执行时的this。

13. 实现深拷贝

14. Promise

15. javascript的执行上下文和执行栈，[参考文章](https://juejin.im/post/5c77365c6fb9a049b2228e4a)

16. this，[参考文章](https://github.com/YvetteLau/Blog/issues/6)

17. 执行栈和上下文

### 手写题

### 算法题

1. 有效的括号字符串----使用栈这种数据结构。

2. 双指针


## React

1. 受控组件和非受控组件

    这个概念主要针对的是表单元素的数据管理。受控组件的表单数据是由React来管理，即state管理表单数据，表单元素触发事件通过setState()来更新数据。[官方文档-受控组件][8]

    而非受控组件，表单数据是由DOM节点管理，可以通过ref获取表单数据。

    在React组件渲染时，表单的value属性会覆盖DOM节点中的值。这时可以通过defaultValue属性给表单赋默认值。

    `<input type="file" />`一直是个非受控组件，获取上传的文件数据，需通过ref。

    [官方文档-非受控组件][9]

2. context

    主要是为了解决prop多层传递的问题，常用的场景例如theme、缓存数据等。

    如果只有最底层的组件用到了上层传递的prop，层层传递prop就会显得很麻烦。这是可以考虑将最底层的组件提升的高的层次，获取数据后，将组件自身传递下去。

    包含4个API：

    React.createContext(defaultValue)

    Context.Provider，组件，接受value属性

    Class.contextType，类上的静态属性，可以在class组件中通过this.context获取Context上的值。

    Context.Consumer，组件，可以是的函数组件使用Context上的值，传递给函数的value值就是Context上的值。

    Context.displayName，React DevTools使用该字符串确定context要显示的内容。

    [官方文档-context][10]

3. render prop

    组件的render属性是一个函数，函数返回需要渲染的内容。这样就可以动态的在组件中渲染内容。

    具体说：render prop是一个用于告知组件需要渲染什么内容的函数prop。 

    这样组件就是可以实现复用，[官方文档-render prop][11]

4. code-spliting

    代码分割是为了避免打包时出现大体积的代码包。

    代码分割的最佳方式是动态`import()`语法。webpack遇到这个语法会自动进行代码分割。

    第三方库[`react-loadble`](https://github.com/jamiebuilds/react-loadable)就是一种解决方案，核心思路为：高阶组件+ webpack dynamic import。

    react本身提供了`React.lazy`和`Suspense`来实现代码分割。

    [官方文档-lazy](https://react.docschina.org/docs/code-splitting.html?#reactlazy)

    [lazy和Suspense理解](https://juejin.im/post/5c7d4a785188251b921f4e26)

5. Fragment

    可以无需在DOM中添加额外节点。

6. Refs and the DOM

    [官方文档--refs](https://react.docschina.org/docs/refs-and-the-dom.html)

## Vue

## 前端工程化

## 浏览器

## HTTP

[HTTP学习文章1][12]
[HTTPS学习文章][14]





[1]: https://juejin.im/post/5aae076d6fb9a028cc6100a9#heading-11
[2]: https://q.shanyue.tech/interview.html
[3]: https://juejin.im/entry/5ad2d3bff265da237a4d75dd
[4]: https://juejin.im/post/5aa78fe66fb9a028d2079ca4
[5]: https://segmentfault.com/a/1190000021860580
[6]: https://mp.weixin.qq.com/s/g9af1J6nnOoABB1VWnKOkg
[7]: https://juejin.im/post/5da32d43e51d45781d5e4bdf
[8]: https://react.docschina.org/docs/forms.html#controlled-components
[9]: https://react.docschina.org/docs/uncontrolled-components.html
[10]: https://react.docschina.org/docs/context.html
[11]: https://react.docschina.org/docs/render-props.html
[12]: https://segmentfault.com/a/1190000021551892
[13]: https://segmentfault.com/a/1190000018799827
[14]: https://segmentfault.com/a/1190000022012971