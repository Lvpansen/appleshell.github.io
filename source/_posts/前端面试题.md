---
title: 前端面试题
date: 2020-02-26 00:28:21
tags: 面试
---

记录一篇面试相关的文章，这样就不用每次都要去搜面试相关的内容了。

<!-- more -->

[前端综合面试题][1]，面试题的分类可以按照这篇文章来，具体的面试题，尤其是原理部分的，由于工作中用不到，死记硬背很快就会忘（当然明天就要面试还是要的）。原理部分就多看多理解，实践部分的内容就一定要动手敲，眼高手低，只会是眼睛懂了，剩下都没懂。

[面经大全][2]，包含了众多的面试文章，包括面试题和面试文章。

## css

css 样式表的分类和优先级、css 选择器、盒模型、定位、布局、flex、Grid、媒体查询、动画、css 文件在浏览器中的加载

[css 面试题 1][3]，答案可能有问题，自己去官方资料中找答案。
[css 面试题 2][7]

css 的大部分知识点是需要记和背的，但最重要的是在项目中使用，才能做到掌握。因为 css 是跟页面显示效果有关的，只有实践了，才能真正立即每个属性的含义。

1. BFC

   [参考文章](https://juejin.im/post/59b73d5bf265da064618731d)

## js

[js 原生知识面试题 1][13]
[面试总结 (含六个方向)](https://mp.weixin.qq.com/s/HRurOLPnZRdBcZgr_gY4HA)

### 概念性知识

1. 考查知识点：原型

   ```js
   function Person(name) {
     this.name = name;
   }
   let p = new Person("Tom");
   ```

   问题 1：`p.__protp__`等于什么------------Person.prototype

   问题 2：`Person.protytype`等于什么------------Function.prototype

   要记住的知识点：

   - prototype 属性是个对象，是函数才拥有的属性，声明函数时这个属性被自动创建。
   - 实例的**proto**属性（原型）等于其构造函数的 prototype 属性。
   - 原型链是通过**proto**属性形成的。
   - 函数都是由 new Function()创建的，因此所有函数（包括 js 自带的基础构造函数，如 Object，Array，Function，Number，Boolean，String，Date，RegExp 等）的**protp**属性指向的都是 Function.prototype。即 js 中所有函数都是 Function 函数的实例，包括 Function 自己。
   - 原型链的终点是 Object.prototype。Object.prototype.**proto**是 null。
   - 更详细的内容看[这篇文章][4]


    再看看这道题目：

      ```js
      var foo = {},
      F = function(){};
      Object.prototype.a = 'value a';
      Function.prototype.b = 'value b';

      console.log(foo.a)
      console.log(foo.b)
      console.log(F.a)
      console.log(F.b)
      ```

2. new 操作符都干了啥。

- 新建一个对象
- 将对象的**prptp**属性指向构造函数的原型对象，即 prototype
- 通过 call 调用构造函数。call 的参数是刚创建的对象，即构造函数内的 this 指向刚创建的对象。
- 返回创建的对象。

但是需要注意：构造函数没有返回值，显示返回一个对象，显示返回非对象类型的值三种情况的区别。

3. 以下代码输出啥

```js
function Foo() {
  getName = function() {
    alert(1);
  };
  return this;
}
Foo.getName = function() {
  alert(2);
};
Foo.prototype.getName = function() {
  alert(3);
};
var getName = function() {
  alert(4);
};
function getName() {
  alert(5);
}

//请写出以下输出结果：
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

答案请看：[这里]:[5]

4. 正向代理和反向代理

正向代理：翻墙访问国外网站就是正向代理的例子，正向代理服务器 Apache。用户访问的是目标网站的地址
反向代理：使用 nginx 解决跨域问题，用户访问的是 nginx 这个 Web 服务器的地址。

5. js 事件循环

这里面涉及到知识点比较多：宏任务和微任务的概念，事件循环执行机制，Promise，async/await。

参考[这篇文章][6]，这篇文章里难理解的点是 async/await 执行顺序，await 会产生一个微任务（Promise.then 也是微任务），主要理解产生这个微任务的时机。新版本的 chorme 执行顺序有所不同，需要理解和记忆。

6. ajax 原理，手写实现。

7. 闭包

8. js 数据类型和类型转换（包括隐式转换）

9. 防抖和节流

   防抖和节流都是为了防止函数的频繁多次执行。两者的区别是，当用户一直触发一个函数，且触发函数的间隔小于设置的时间，防抖只会执行一次，节流会每隔一段时间执行一次。

10. [] == ![]，返回值是什么？

    考察点：`==`的类型转换规则，运算符优先级（`!`优先级高于`==`）

    1. 首先判断两者类型是否相同，如果相等，判断值是否相等.
    2. 如果类型不同，进行类型转换
    3. 判断比较的是否是 null 或者是 undefined, 如果是, 返回 true .
    4. 判断两者类型是否为 string 和 number, 如果是, 将字符串转换成 number
    5. 判断其中一方是否为 boolean, 如果是, 将 boolean 转为 number 再进行判断
    6. 判断其中一方是否为 object 且另一方为 string、number 或者 symbol , 如果是, 将 object 转为原始类型再进行判断
    7. 要注意的是两方都是复杂数据类型，比较的是引用地址。`[] == []`返回值是 false。

11. call 实现的原理，[参考这里](https://segmentfault.com/a/1190000018799827#item-0-15)

    call 函数中的 this 指向的是调用 call 的函数。

    在传入的对象上调用函数，使得调用函数的 this 指向传入的对象。

    ```js
    Function.prototype.my_call = function(context, ...rest) {
      if (!context) {
        context = window === "undefined" ? global : window;
      }

      context.fn = this; // this指向的是调用call的函数。例如Array.push.call(obj, 1, 2), this指向的就是Array.push函数。
      let args = rest; // 获取除了this指向对象之外的参数
      let result = context.fn(...rest); //fn是调用call的函数，fn中的this指向context，实现改变this指向的功能。
      delete context.fn;
      return result;
    };
    ```

    apply 实现原理和 call 一样，只有第二个参数不同，是个数组。

    bind 和 call/apply 的一个重要区别是：一个函数通过 call/apply 调用时，会直接调用执行。而 bind 会创建一个新函数，这个新函数被调用时，bind()的第一个参数就是它执行时的 this。

12. 实现深拷贝

13. Promise

14. 执行上下文和执行栈，

    > 基本概念

    执行上下文是指当前 javascript 被解析和执行时所在环境的抽象概念。JavaScript 所有代码都在执行上下文中执行。

    > 执行上下文类型

    全局执行上下文、函数执行上下文、Eval 函数执行上下文（不常用）

    > 执行上下文的生命周期

    创建阶段 → 执行阶段 → 回收阶段

    > 创建阶段的过程

    函数被调用时，未执行代码前会做下面三件事

    - 创建变量对象：初始化 arguments 参数，提升函数声明和变量声明。
    - 创建作用域链，作用域链是在变量对象后之后创建的。
    - this 值的决定，即 this 绑定

    > 相关的知识点

    - 变量声明提升和函数声明提升

      变量声明提升只提升了声明，没有提升赋值，因此变量初始值是 undefined。函数声明提升会把整个函数提升。

      当函数名和变量名相同时，在提升时，函数声明的优先级是高于变量声明。也就是说函数声明会覆盖变量声明。但可以重新赋值。

      ```js
      console.log(a); // function a(){}
      function a() {}
      var a = "vv";
      console.log(a);
      ```

      如果函数有形参：

      ```js
      function test(arg) {
        console.log(arg); // 打印arg函数
        var arg = "hello";
        console.log(arg); // 打印 hello
        function arg() {
          console.log("hello world");
        }
        console.log(arg); // 打印hello
      }
      test("hi");
      ```

      这个函数执行时，创建这个函数的执行上下文。首先初始化参数，形参赋值；然后预解析，声明提升;船舰这个函数的私有作用域；然后执行代码。

    > 执行栈

    顾名思义，就是一个存放执行上下文的结构，遵循先进后出的原则。当有多个函数时，js 就是创建多个执行上下文，执行找就决定了执行上下文的执行顺序。

    当 JavaScript 引擎第一次遇到 js 代码时，创建一个全局的执行上下文并压入当前的执行栈。此时全局执行上下文位于栈顶，开始执行全局执行上下文中的代码。

    之后，每当遇到函数调用时，为该函数创建函数执行上下文，压入栈顶。

    js 引擎会执行处于栈顶的执行上下文，当该函数执行完毕时，这个执行上下文弹出栈顶。控制流程继续执行当前栈中的执行上下文。

    全局执行上下文只有一个。

    ```js
    let a = "Hello World!";

    function first() {
      console.log("Inside first function");
      second();
      console.log("Again inside first function");
    }

    function second() {
      console.log("Inside second function");
    }

    first();
    console.log("Inside Global Execution Context");
    ```

    上述代码开始执行时，js 引擎创建全局执行上下文，压入栈内。当遇到`first()`函数调用时，js 引擎为该函数创建一个函数执行上下文，压入栈顶。

    first 函数执行上下文执行时，遇到`second()`函数调用，js 引擎为该函数创建以函数执行上下文，压入栈顶。

    second 函数执行完毕后出栈，first 函数执行上下文此时位于栈顶，继续执行 fist 函数。

    first 函数执行完毕后出栈，全局执行上下文位于栈顶，继续执行全局执行上下文中的代码。

    一旦所有代码执行完毕，全局执行上下文从栈中移除。

[参考文章 1](https://juejin.im/post/5c77365c6fb9a049b2228e4a)

[参考文章 2](https://mp.weixin.qq.com/s/IfLjuSVZorM_JT4u8Kffxg)

14. Promise 和 async/await

[async/await 学习](https://juejin.im/post/5b1ffff96fb9a01e345ba704)

15. this，[参考文章](https://github.com/YvetteLau/Blog/issues/6)

16. 作用域

    作用域负责收集和维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。————摘自《你不知道的 JavaScript（上卷）》

    作用域有两种工作模式：词法作用域和动态作用域。js 采用的**词法作用域**，即 js 的作用域是由书写代码时变量和函数声明的位置决定的，(也可以理解成是在代码编译阶段，变量和函数声明的作用域就确定了)

### 手写题

### 算法题

1. 有效的括号字符串----使用栈这种数据结构。

2. 双指针

## React

1. 受控组件和非受控组件

   这个概念主要针对的是表单元素的数据管理。受控组件的表单数据是由 React 来管理，即 state 管理表单数据，表单元素触发事件通过 setState()来更新数据。[官方文档-受控组件][8]

   而非受控组件，表单数据是由 DOM 节点管理，可以通过 ref 获取表单数据。

   在 React 组件渲染时，表单的 value 属性会覆盖 DOM 节点中的值。这时可以通过 defaultValue 属性给表单赋默认值。

   `<input type="file" />`一直是个非受控组件，获取上传的文件数据，需通过 ref。

   [官方文档-非受控组件][9]

2. context

   主要是为了解决 prop 多层传递的问题，常用的场景例如 theme、缓存数据等。

   如果只有最底层的组件用到了上层传递的 prop，层层传递 prop 就会显得很麻烦。这是可以考虑将最底层的组件提升的高的层次，获取数据后，将组件自身传递下去。

   包含 4 个 API：

   React.createContext(defaultValue)

   Context.Provider，组件，接受 value 属性

   Class.contextType，类上的静态属性，可以在 class 组件中通过 this.context 获取 Context 上的值。

   Context.Consumer，组件，可以是的函数组件使用 Context 上的值，传递给函数的 value 值就是 Context 上的值。

   Context.displayName，React DevTools 使用该字符串确定 context 要显示的内容。

   [官方文档-context][10]

3. render prop

   组件的 render 属性是一个函数，函数返回需要渲染的内容。这样就可以动态的在组件中渲染内容。

   具体说：render prop 是一个用于告知组件需要渲染什么内容的函数 prop。

   这样组件就是可以实现复用，[官方文档-render prop][11]

4. code-spliting

   代码分割是为了避免打包时出现大体积的代码包。

   代码分割的最佳方式是动态`import()`语法。webpack 遇到这个语法会自动进行代码分割。

   第三方库[`react-loadble`](https://github.com/jamiebuilds/react-loadable)就是一种解决方案，核心思路为：高阶组件+ webpack dynamic import。

   react 本身提供了`React.lazy`和`Suspense`来实现代码分割。

   [官方文档-lazy](https://react.docschina.org/docs/code-splitting.html?#reactlazy)

   [lazy 和 Suspense 理解](https://juejin.im/post/5c7d4a785188251b921f4e26)

5. Fragment

   可以无需在 DOM 中添加额外节点。

6. Refs and the DOM

   [官方文档--refs](https://react.docschina.org/docs/refs-and-the-dom.html)

7. state & prosp

   [ReactJS: Props vs. State](https://lucybain.com/blog/2016/react-state-vs-pros/)

   [props vs state](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md)

   第一篇文章讲的很通俗。以下是对第二篇文章的拙劣翻译。

   > 相同点：

   - props 和 state 都是纯 JS 对象（plain JS objects）
   - props 和 state 变化都会触发 render 更新
   - props 和 state 都是确定性的（deterministic）。如果一个组件对相同的 props 和 state 组合产生了不同的输出，那肯定就是写的代码哪里出错了。

   > 不同点

   props：

   - props 可以理解成一个组件的配置（configuration）或者选项（options）；
   - 对于接收 props 的组件而言，它是从上层组件传递，并且它是不可变的。
   - 组件不能修改它的 props，但负责整合它子组件的 props。

   state:

   - 组件挂载时，state 生成并有默认值。之后可被事件改变。
   - 组件管理其本身的内部 state，但是和其子组件的 state 无关。因此 state 是 private 的。

     |                                               | props | state |
     | --------------------------------------------- | ----- | ----- |
     | Can get initial value from parent Component ? | Yes   | Yes   |
     | can be changed by parent Component ?          | Yes   | No    |
     | can set default values inside Component ?     | Yes   | Yes   |
     | Can change inside Component ?                 | No    | Yes   |
     | Can set initial value for child Components ?  | Yes   | Yes   |
     | Can change in child Components ?              | Yes   | No    |

     注意 state 和 porps 从父组件接收的初始值会覆盖在组件中定义的默认值。

     组件中，state 是可选择的。state 会增加复杂性，削减可预见性（可理解为确定性）。因此不使用 state 是最好的。虽然我们不可能在应用中不使用 state，但应尽量少的使用状态组件。

     无状态组件--只包含 props，状态组件--包含 props 和 state。

8. 学习 react 文档中 React 哲学章节

   这一章节主要介绍的是用 React 开发应用的思考流程。

   1. 将 UI 设计划分为组件层级。

      划分的原则是根据单一功能原则来判定组件的范围。一个组件原则上只负责一个功能。如果一个组件需要负责更多的功能，这时就要考虑将它拆分成更小的组件。

      拿到设计稿或原型时，就根据以上的思路进行 UI 划分，确定好组件以及组件层级。之后再着手开始开发。

      这里需要了解[容器组件和展示组件](https://medium.com/@learnreact/container-components-c0e67432e005)，还有[这篇](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)，[中文版](https://segmentfault.com/a/1190000013670158)

   2. 创建一个静态版本的应用

      这里面主要分两部分：开发静态页面和添加交互，这两个过程分开进行。

      对于开发静态页面，在创建可复用组件时，使用 props 传入所需的数据，尽量不需要 state。state 代表的是会随时间产生变化的数据，应当仅在实现交互的时候使用。

      开发形式分两种：自上而下和自下而上。自上而下适合简单的应用，先开发层级高的；而自下而上适合复杂的大型应用，先开发基础组件，进而构建高层级组件。

   3. 确定 state 的最小且完整的表示

      目的是减少不必要的 state，能用现有 state 计算出来的，就不要额外定义 state 变量。

      | 是否属于 state                               | Yes | No  |
      | -------------------------------------------- | --- | --- |
      | 该数据由父组件通过 props 传递而来            | ×   | √   |
      | 该数据随着时间推移保持不变                   | ×   | √   |
      | 该数据可以根据其他 state 或者 props 计算得到 | ×   | √   |

   4. 确定 state 放置的位置

      概括来说，应放在需要使用这个 state 的组件的共同的父组件中

   5. 添加反向数据流

   以上步骤已经实现了自上而下的数据传递，最后通过给子组件传递回调函数，子组件触发这个函数，将数据自下而上的传递出来。

9. 容器组件

   ```
   A container does data fetching and rendrs its corresponding sub-component.
   ```

   容器负责获取请求数据，并渲染其相应的子组件。

   举个例子，下列组件中包含了数据请求和数据渲染

   ```jsx
   class CommentList extends React.Component {
     this.state = { comments: [] };

     componentDidMount() {
       fetSomeComments(comments =>
       this.setState({ comments }));
     }

     render() {
       return (
         <ul>
           {this.state.commnets.map(c => (
             <li>{c.body}-{c.author}</li>
           ))}
         </ul>
       )
     };
   }
   ```

   如果换成容器组件：

   ```jsx
   class CommentListContainer extends React.Component {
     this.state = { comments: [] };

     componentDidMount() {
       fetSomeComments(comments =>
       this.setState({ comments }));
     }

     render() {
       return <ComponentList comments={this.state.comments} />
     }
   }
   ```

   下面是容器组件的子组件：

   ```jsx
   const ComponentList = props => (
     <ul>
       {props.comments.map(c => (
         <li>
           {c.body}-{c.author}
         </li>
       ))}
     </ul>
   );
   ```
   对比两种写法：

   我们实现数据请求和数据渲染分离；

   实现了CommentList组件的复用；

   CommentList组件可以设置PropsType;

10. Ref & DOM & forwardref

  ref可以理解为获取一个组件的节点，当这个组件是React自定义组件时，ref获取的时这个组件的实例；组件是原生元素时，获取的是DOM元素。

  创建Ref: 使用`React.createRef()`，然后通过ref属性附加到目标组建上。

  访问Ref：通过`ref.current`访问关联的目标节点

  ```jsx
  class ColorBox extends React.PureComponent {
    getColor = () => {
      console.log(this.props.color);
    };
    render() {
      return (
        <div>
          <span>颜色值是：{this.props.color}</span>
          <div
            style={{
              width: "100px",
              height: "100px",
              background: this.props.color || "green"
            }}
          />
        </div>
      );
    }
  }

  export default class App extends React.PureComponent {
    constructor(props) {
      super(props);
      this.myRef = React.createRef();
      this.boxRef = React.createRef();
    }
    handleRef = () => {
      console.log(this.myRef);
      console.log(this.boxRef);
    };
    render() {
      return (
        <>
          <div ref={this.myRef}>hello</div>
          <button onClick={this.handleRef}>click</button>
          <ColorBox ref={this.boxRef} color="blue" />
        </>
      );
    }
  }
  ```
  上述例子中myRef.current的值是div这个DOM元素；boxRef.current的值是ColorBox这个组件的实例。

  函数组件是不能使用ref属性的，因为函数组件没有实例。但是函数组件内部可以试通过useRef使用ref属性，只要它指向的是class组件或者DOM元素。

  创建ref的另一种方式是“回调refs”，ref属性接受的是一个函数，这个函数的参数就是React组件实例或者DOM元素。

  ref会在组件挂载前获取赋值，在组件卸载前被赋值null。

  ref转发，我的理解是获取组件中的元素节点，而不是组件本身节点。例如，一个class组件中封装了input元素，给这个class组件设置ref属性，获取的是这个组件的实例；而通过forwardRef，可以把class组件上的ref属性透传到input元素上，从而可以获取input这个DOM元素。

## Vue

## React 和 Vue 的区别

1. 写法的不同：

   React：JSX 语法，css 文件独立

   Vue: templaet 模板，HTML，JS，CSS 卸载.vue 文件中。

2. 触发数据变化的方式

   React：通过`setState`来修改 state 中的数据

   Vue: 直接修改 data 中的数据。例如：`this.name = 'jack'`

3. 数据流：（input 标签为例）

   React：单向数据流

   Vue: 双向数据流

4. 数据传递

   React：父组件通过 props 向子组件传递数据，方法也可以传递。子组件则通过传递的函数将数据传递给父组件。

   Vue: 父组件通过 v-bind 传递数据，子组件通过 props 接收数据。子组件通过触发事件，父组件监听事件，达到子组件向父组件传递数据的目的。

5. 事件传递

   React：直接将函数作为属性传递给子组件，子组件通过事件触发这个函数。

   Vue: 子组件通过 emit 传递事件，父组件监听传递的事件。

## 前端工程化

## 浏览器

## HTTP

[HTTP 学习文章 1][12]
[HTTPS 学习文章][14]

[1]: https://juejin.im/post/5aae076d6fb9a028cc6100a9#heading-11
[2]: https://q.shanyue.tech/interview.html
[3]: https://juejin.im/entry/5ad2d3bff265da237a4d75dd
[4]: https://juejin.im/post/5aa78fe66fb9a028d2079ca4
[5]: https://segmentfault.com/a/1190000021860580
[6]: https://mp.weixin.qq.com/s/g9af1J6nnOoABB1VWnKOkg
[7]: https://juejin.im/post/5da32d43e51d45781d5e4bdf
[8]: https://react.docschina.org/docs/forms.html#controlled-components
[9]: https://react.docschina.org/docs/uncontrolled-components.html
[10]: https://react.docschina.org/docs/context.html
[11]: https://react.docschina.org/docs/render-props.html
[12]: https://segmentfault.com/a/1190000021551892
[13]: https://segmentfault.com/a/1190000018799827
[14]: https://segmentfault.com/a/1190000022012971
