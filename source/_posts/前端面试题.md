---
title: 前端面试题
date: 2020-02-26 00:28:21
tags: 面试
---

记录一篇面试相关的文章，这样就不用每次都要去搜面试相关的内容了。

<!-- more -->

[前端综合面试题][1]，面试题的分类可以按照这篇文章来，具体的面试题，尤其是原理部分的，由于工作中用不到，死记硬背很快就会忘（当然明天就要面试还是要的）。原理部分就多看多理解，实践部分的内容就一定要动手敲，眼高手低，只会是眼睛懂了，剩下都没懂。

[面经大全][2]，包含了众多的面试文章，包括面试题和面试文章。

## css

css样式表的分类和优先级、css选择器、盒模型、定位、布局、flex、Grid、媒体查询、动画、css文件在浏览器中的加载

[css面试题1][3]，答案可能有问题，自己去官方资料中找答案。
[css面试题2][7]

css的大部分知识点是需要记和背的，但最重要的是在项目中使用，才能做到掌握。因为css是跟页面显示效果有关的，只有实践了，才能真正立即每个属性的含义。

1. BFC

    [参考文章](https://juejin.im/post/59b73d5bf265da064618731d)

## js

[js原生知识面试题1][13]
[面试总结 (含六个方向)](https://mp.weixin.qq.com/s/HRurOLPnZRdBcZgr_gY4HA)

### 概念性知识

1. 考查知识点：原型

    ```js
    function Person(name) {
      this.name = name
    }
    let p = new Person('Tom')
    ```

    问题1：`p.__protp__`等于什么------------Person.prototype

    问题2：`Person.protytype`等于什么------------Function.prototype

    要记住的知识点：

    * prototype属性是个对象，是函数才拥有的属性，声明函数时这个属性被自动创建。
    * 实例的__proto__属性（原型）等于其构造函数的prototype属性。
    * 原型链是通过__proto__属性形成的。
    * 函数都是由new Function()创建的，因此所有函数（包括js自带的基础构造函数，如Object，Array，Function，Number，Boolean，String，Date，RegExp等）的__protp__属性指向的都是Function.prototype。即js中所有函数都是Function函数的实例，包括Function自己。
    * 原型链的终点是Object.prototype。Object.prototype.__proto__是null。
    * 更详细的内容看[这篇文章][4]


    再看看这道题目：

      ```js
      var foo = {},
      F = function(){};
      Object.prototype.a = 'value a';
      Function.prototype.b = 'value b';

      console.log(foo.a)   
      console.log(foo.b)    
      console.log(F.a)      
      console.log(F.b)  
      ```

2. new 操作符都干了啥。

* 新建一个对象
* 将对象的__prptp__属性指向构造函数的原型对象，即prototype
* 通过call调用构造函数。call的参数是刚创建的对象，即构造函数内的this指向刚创建的对象。
* 返回创建的对象。

但是需要注意：构造函数没有返回值，显示返回一个对象，显示返回非对象类型的值三种情况的区别。

3. 以下代码输出啥
  ```js
  function Foo() {
    getName = function () { alert (1); };
    return this;
  }
  Foo.getName = function () { alert (2);};
  Foo.prototype.getName = function () { alert (3);};
  var getName = function () { alert (4);};
  function getName() { alert (5);}
  
  //请写出以下输出结果：
  Foo.getName();
  getName();
  Foo().getName();
  getName();
  new Foo.getName();
  new Foo().getName();
  new new Foo().getName();
  ```
  答案请看：[这里]:[5]


4. 正向代理和反向代理

正向代理：翻墙访问国外网站就是正向代理的例子，正向代理服务器Apache。用户访问的是目标网站的地址
反向代理：使用nginx解决跨域问题，用户访问的是nginx这个Web服务器的地址。

5. js事件循环

这里面涉及到知识点比较多：宏任务和微任务的概念，事件循环执行机制，Promise，async/await。

参考[这篇文章][6]，这篇文章里难理解的点是async/await执行顺序，await会产生一个微任务（Promise.then也是微任务），主要理解产生这个微任务的时机。新版本的chorme执行顺序有所不同，需要理解和记忆。


6. ajax原理，手写实现。

7. 闭包

8. js数据类型和类型转换（包括隐式转换）

9. 防抖和节流

    防抖和节流都是为了防止函数的频繁多次执行。两者的区别是，当用户一直触发一个函数，且触发函数的间隔小于设置的时间，防抖只会执行一次，节流会每隔一段时间执行一次。

10. [] == ![]，返回值是什么？

    考察点：`==`的类型转换规则，运算符优先级（`!`优先级高于`==`）

    1. 首先判断两者类型是否相同，如果相等，判断值是否相等.
    2. 如果类型不同，进行类型转换
    3. 判断比较的是否是 null 或者是 undefined, 如果是, 返回 true .
    4. 判断两者类型是否为 string 和 number, 如果是, 将字符串转换成 number
    5. 判断其中一方是否为 boolean, 如果是, 将 boolean 转为 number 再进行判断
    6. 判断其中一方是否为 object 且另一方为 string、number 或者 symbol , 如果是, 将 object 转为原始类型再进行判断
    7. 要注意的是两方都是复杂数据类型，比较的是引用地址。`[] == []`返回值是false。

11. call实现的原理，[参考这里](https://segmentfault.com/a/1190000018799827#item-0-15)

    call函数中的this指向的是调用call的函数。

    在传入的对象上调用函数，使得调用函数的this指向传入的对象。

    ```js
    Function.prototype.my_call = function(context, ...rest) {
      if(!context) {
        context = window === 'undefined' ? global : window;
      }

      context.fn = this; // this指向的是调用call的函数。例如Array.push.call(obj, 1, 2), this指向的就是Array.push函数。
      let args = rest; // 获取除了this指向对象之外的参数
      let result = context.fn(...rest)  //fn是调用call的函数，fn中的this指向context，实现改变this指向的功能。
      delete context.fn
      return result
    }
    ```

    apply实现原理和call一样，只有第二个参数不同，是个数组。

    bind和call/apply的一个重要区别是：一个函数通过call/apply调用时，会直接调用执行。而bind会创建一个新函数，这个新函数被调用时，bind()的第一个参数就是它执行时的this。

12. 实现深拷贝

13. Promise

14. 执行上下文和执行栈，

    > 基本概念

    执行上下文是指当前javascript被解析和执行时所在环境的抽象概念。JavaScript所有代码都在执行上下文中执行。

    > 执行上下文类型

    全局执行上下文、函数执行上下文、Eval函数执行上下文（不常用）

    > 执行上下文的生命周期

    创建阶段 → 执行阶段 → 回收阶段

    > 创建阶段的过程

      函数被调用时，未执行代码前会做下面三件事

    * 创建变量对象：初始化arguments参数，提升函数声明和变量声明。
    * 创建作用域链，作用域链是在变量对象后之后创建的。
    * this值的决定，即this绑定

    > 相关的知识点

    * 变量声明提升和函数声明提升

      变量声明提升只提升了声明，没有提升赋值，因此变量初始值是undefined。函数声明提升会把整个函数提升。

      当函数名和变量名相同时，在提升时，函数声明的优先级是高于变量声明。也就是说函数声明会覆盖变量声明。但可以重新赋值。

      ```js
      console.log(a) // function a(){}
      function a(){}
      var a = 'vv'
      console.log(a)
      ```
      如果函数有形参：

      ```js
      function test(arg){
        console.log(arg)  // 打印arg函数
        var arg = 'hello'
        console.log(arg) // 打印 hello
        function arg(){
          console.log('hello world') 
        }
        console.log(arg);  // 打印hello
      }
      test('hi');
      ```

      这个函数执行时，创建这个函数的执行上下文。首先初始化参数，形参赋值；然后预解析，声明提升;船舰这个函数的私有作用域；然后执行代码。

    > 执行栈

    顾名思义，就是一个存放执行上下文的结构，遵循先进后出的原则。当有多个函数时，js就是创建多个执行上下文，执行找就决定了执行上下文的执行顺序。

    当JavaScript引擎第一次遇到js代码时，创建一个全局的执行上下文并压入当前的执行栈。此时全局执行上下文位于栈顶，开始执行全局执行上下文中的代码。

    之后，每当遇到函数调用时，为该函数创建函数执行上下文，压入栈顶。

    js引擎会执行处于栈顶的执行上下文，当该函数执行完毕时，这个执行上下文弹出栈顶。控制流程继续执行当前栈中的执行上下文。

    全局执行上下文只有一个。

    ```js
    let a = 'Hello World!';

    function first() {
      console.log('Inside first function');
      second();
      console.log('Again inside first function');
    }

    function second() {
      console.log('Inside second function');
    }

    first();
    console.log('Inside Global Execution Context');
    ```

    上述代码开始执行时，js引擎创建全局执行上下文，压入栈内。当遇到`first()`函数调用时，js引擎为该函数创建一个函数执行上下文，压入栈顶。

    first函数执行上下文执行时，遇到`second()`函数调用，js引擎为该函数创建以函数执行上下文，压入栈顶。

    second函数执行完毕后出栈，first函数执行上下文此时位于栈顶，继续执行fist函数。

    first函数执行完毕后出栈，全局执行上下文位于栈顶，继续执行全局执行上下文中的代码。

    一旦所有代码执行完毕，全局执行上下文从栈中移除。

[参考文章1](https://juejin.im/post/5c77365c6fb9a049b2228e4a)

[参考文章2](https://mp.weixin.qq.com/s/IfLjuSVZorM_JT4u8Kffxg)

14. Promise和async/await

  [async/await学习](https://juejin.im/post/5b1ffff96fb9a01e345ba704)

15. this，[参考文章](https://github.com/YvetteLau/Blog/issues/6)

16. 作用域

    作用域负责收集和维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。————摘自《你不知道的JavaScript（上卷）》

    作用域有两种工作模式：词法作用域和动态作用域。js采用的**词法作用域**，即js的作用域是由书写代码时变量和函数声明的位置决定的，(也可以理解成是在代码编译阶段，变量和函数声明的作用域就确定了)



### 手写题

### 算法题

1. 有效的括号字符串----使用栈这种数据结构。

2. 双指针


## React

1. 受控组件和非受控组件

    这个概念主要针对的是表单元素的数据管理。受控组件的表单数据是由React来管理，即state管理表单数据，表单元素触发事件通过setState()来更新数据。[官方文档-受控组件][8]

    而非受控组件，表单数据是由DOM节点管理，可以通过ref获取表单数据。

    在React组件渲染时，表单的value属性会覆盖DOM节点中的值。这时可以通过defaultValue属性给表单赋默认值。

    `<input type="file" />`一直是个非受控组件，获取上传的文件数据，需通过ref。

    [官方文档-非受控组件][9]

2. context

    主要是为了解决prop多层传递的问题，常用的场景例如theme、缓存数据等。

    如果只有最底层的组件用到了上层传递的prop，层层传递prop就会显得很麻烦。这是可以考虑将最底层的组件提升的高的层次，获取数据后，将组件自身传递下去。

    包含4个API：

    React.createContext(defaultValue)

    Context.Provider，组件，接受value属性

    Class.contextType，类上的静态属性，可以在class组件中通过this.context获取Context上的值。

    Context.Consumer，组件，可以是的函数组件使用Context上的值，传递给函数的value值就是Context上的值。

    Context.displayName，React DevTools使用该字符串确定context要显示的内容。

    [官方文档-context][10]

3. render prop

    组件的render属性是一个函数，函数返回需要渲染的内容。这样就可以动态的在组件中渲染内容。

    具体说：render prop是一个用于告知组件需要渲染什么内容的函数prop。 

    这样组件就是可以实现复用，[官方文档-render prop][11]

4. code-spliting

    代码分割是为了避免打包时出现大体积的代码包。

    代码分割的最佳方式是动态`import()`语法。webpack遇到这个语法会自动进行代码分割。

    第三方库[`react-loadble`](https://github.com/jamiebuilds/react-loadable)就是一种解决方案，核心思路为：高阶组件+ webpack dynamic import。

    react本身提供了`React.lazy`和`Suspense`来实现代码分割。

    [官方文档-lazy](https://react.docschina.org/docs/code-splitting.html?#reactlazy)

    [lazy和Suspense理解](https://juejin.im/post/5c7d4a785188251b921f4e26)

5. Fragment

    可以无需在DOM中添加额外节点。

6. Refs and the DOM

    [官方文档--refs](https://react.docschina.org/docs/refs-and-the-dom.html)

7. state & prosp

    [ReactJS: Props vs. State](https://lucybain.com/blog/2016/react-state-vs-pros/)
    
    [props vs state](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md)

    第一篇文章讲的很通俗。以下是对第二篇文章的拙劣翻译。

    > 相同点：

    * props和state都是纯JS对象（plain JS objects）
    * props和state变化都会触发render更新
    * props和state都是确定性的（deterministic）。如果一个组件对相同的props和state组合产生了不同的输出，那肯定就是写的代码哪里出错了。

    > 不同点

      props：
  
      * props可以理解成一个组件的配置（configuration）或者选项（options）；
      * 对于接收props的组件而言，它是从上层组件传递，并且它是不可变的。
      * 组件不能修改它的props，但负责整合它子组件的props。

      state:

      * 组件挂载时，state生成并有默认值。之后可被事件改变。
      * 组件管理其本身的内部state，但是和其子组件的state无关。因此state是private的。

        |  | props | state |
        | --- | --- | --- |
        | Can get initial value from parent Component ? | Yes | Yes |
        | can be changed by parent Component ? | Yes | No |
        | can set default values inside Component ? | Yes | Yes |
        | Can change inside Component ? | No | Yes |
        | Can set initial value for child Components ? | Yes | Yes |
        | Can change in child Components ? | Yes | No |

        注意state和porps从父组件接收的初始值会覆盖在组件中定义的默认值。

        组件中，state是可选择的。state会增加复杂性，削减可预见性（可理解为确定性）。因此不使用state是最好的。虽然我们不可能在应用中不使用state，但应尽量少的使用状态组件。

        无状态组件--只包含props，状态组件--包含props和state。

8. 学习react文档中React哲学章节

    这一章节主要介绍的是用React开发应用的思考流程。

    1. 将UI设计划分为组件层级。

        划分的原则是根据单一功能原则来判定组件的范围。一个组件原则上只负责一个功能。如果一个组件需要负责更多的功能，这时就要考虑将它拆分成更小的组件。

        拿到设计稿或原型时，就根据以上的思路进行UI划分，确定好组件以及组件层级。之后再着手开始开发。

        这里需要了解[容器组件和展示组件](https://medium.com/@learnreact/container-components-c0e67432e005)，还有[这篇](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)，[中文版](https://segmentfault.com/a/1190000013670158)

    2. 创建一个静态版本的应用

        这里面主要分两部分：开发静态页面和添加交互，这两个过程分开进行。

        对于开发静态页面，在创建可复用组件时，使用props传入所需的数据，尽量不需要state。state代表的是会随时间产生变化的数据，应当仅在实现交互的时候使用。

        开发形式分两种：自上而下和自下而上。自上而下适合简单的应用，先开发层级高的；而自下而上适合复杂的大型应用，先开发基础组件，进而构建高层级组件。

    3. 确定state的最小且完整的表示

        目的是减少不必要的state，能用现有state计算出来的，就不要额外定义state变量。

        | 是否属于state | Yes | No |
        | --- | --- | --- |
        | 该数据由父组件通过props传递而来 | × | √ |
        | 该数据随着时间推移保持不变 | × | √ |
        | 该数据可以根据其他state或者props计算得到 | × | √ |

    4. 确定state放置的位置

        概括来说，应放在需要使用这个state的组件的共同的父组件中

    5. 添加反向数据流

      以上步骤已经实现了自上而下的数据传递，最后通过给子组件传递回调函数，子组件触发这个函数，将数据自下而上的传递出来。


## Vue

## React和Vue的区别

1. 写法的不同：

    React：JSX语法，css文件独立

    Vue: templaet模板，HTML，JS，CSS卸载.vue文件中。

2. 触发数据变化的方式

    React：通过`setState`来修改state中的数据

    Vue: 直接修改data中的数据。例如：`this.name = 'jack'`

3. 数据流：（input标签为例）

    React：单向数据流

    Vue: 双向数据流

4. 数据传递

    React：父组件通过props向子组件传递数据，方法也可以传递。子组件则通过传递的函数将数据传递给父组件。

    Vue: 父组件通过v-bind传递数据，子组件通过props接收数据。子组件通过触发事件，父组件监听事件，达到子组件向父组件传递数据的目的。

5. 事件传递

    React：直接将函数作为属性传递给子组件，子组件通过事件触发这个函数。

    Vue: 子组件通过emit传递事件，父组件监听传递的事件。

## 前端工程化

## 浏览器

## HTTP

[HTTP学习文章1][12]
[HTTPS学习文章][14]





[1]: https://juejin.im/post/5aae076d6fb9a028cc6100a9#heading-11
[2]: https://q.shanyue.tech/interview.html
[3]: https://juejin.im/entry/5ad2d3bff265da237a4d75dd
[4]: https://juejin.im/post/5aa78fe66fb9a028d2079ca4
[5]: https://segmentfault.com/a/1190000021860580
[6]: https://mp.weixin.qq.com/s/g9af1J6nnOoABB1VWnKOkg
[7]: https://juejin.im/post/5da32d43e51d45781d5e4bdf
[8]: https://react.docschina.org/docs/forms.html#controlled-components
[9]: https://react.docschina.org/docs/uncontrolled-components.html
[10]: https://react.docschina.org/docs/context.html
[11]: https://react.docschina.org/docs/render-props.html
[12]: https://segmentfault.com/a/1190000021551892
[13]: https://segmentfault.com/a/1190000018799827
[14]: https://segmentfault.com/a/1190000022012971