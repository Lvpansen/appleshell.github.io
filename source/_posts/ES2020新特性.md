---
title: ES2020新特性
date: 2020-07-18 09:38:21
tags: Javascript
---

ES2020

<!-- more -->

## BigInt

Why:

目前 JS 中最大的数是`Math.pow(2,53) - 1`，也可以通过`Number.Number.MAX_SAFE_INTEGER`获得，顾名思义，这个数是 js 中可以安全递增的最大整数，超出这个数字之外的计算可能存在精度丢失的问题。

```js
Number.Number.MAX_SAFE_INTEGER + 1 === Number.Number.MAX_SAFE_INTEGER + 2; // true
```

what：

BigInt 是 js 中的一个新的原始数据类型，在超出原来最大数字限制的范围外，也可以安全的进行存储和大数运算。

how:

创建 BigInt 类型数据：

```js
let num = 474384383483n;

let num1 = BigInt(235423424);

typeof num; // "bigint"
typeof num1; // "bigint"

num + 1n === num + 2n; // false

10n == 10 // true

10n / 10n // 2n
20n / 2 // 报错：Cannot mix bigInt adn other types
```

## Dynamic import

why:

在之前的 js 中，当 import 一个 module 时，无论这个 module 中的方法或变量有没有被用到，这个 module 都会被引入。

```js
import React, { Component } from "react";
import { print } from "./moduleA";

class App extends Component {
  handleClick = () => {
    print("moduleA will always be imported");
  };

  render() {
    return <button onClck={this.handleClick}>click</button>;
  }
}
```

what：

动态加载也可以称之为按需加载，可以理解成是原生的 code-splitting。

how:

import(module)方法可以在任何地方调用，返回一个解析为模块对象的 promise

```js
import React, { Component } from "react";

class App extends Component {
  handleClick = () => {
    import("./moduleA")
      .then((module) => {
        moudule.print("moduleA will be imported when you click the button");
      })
      .catch((err) => {
        //
      });
  };

  render() {
    return <button onClck={this.handleClick}>click</button>;
  }
}
```

也可以在 if-else 等条件语句中使用。

## Promise.allSettled

why:

`Promise.all()`方法返回的 promise 的状态由传入的每个 promise 的状态决定，只要有一个状态是 rejected，则返回的 promise 的状态就是 rejected。

```js
const promiseArray = [
  Promise.resolve(100),
  Promise.reject(null),
  Promise.resolve('data release'),
  Promise.reject(new Error('Oh No!'))
]
Promise.all(promiseArray)
  .then(data => {
    console.log('all resolved! the values are:' data)
  })
  .catch(err => {
    console.log('be rejectd! error is ', err)
  })

// be rejectd! error is null
```

what:

`Promise.allSettled()`接受一个 promise 的数组作为参数，返回的 promise 状态指挥变成`fulfilled`，无论传入的每个 promise 的是 resolved 还是 rejected。

how:

```js
const promiseArray = [
    Promise.resolve(100),
    Promise.reject(null),
    Promise.resolve('data release'),
    Promise.reject(new Error('Oh No!'))
  ]
  Promise.allSettled(promiseArray)
    .then(data => {
      console.log(data)
    })
    .catch(err => {
      console.log('be rejectd! error is ', err)
    })

  // [
  //   {status: "fulfilled", value: 100},
  //   {status: "rejected", reason: null},
  //   {status: "fulfilled", value: "data release"},
  //   {status: "rejected", reason: Error: Oh No!}
  // ]
```

## Nullish Coalescing

why: 

  通常情况下在获取值的时候我们会设置默认值，防止默认值是null或者undefined。一般使用`||`来实现，但在ES2020之前会有个问题，可以转化为`false`的所有值，都会获取默认值。

  ```js
  const values = {
    nullValue: null,
    numberValue: 400,
    zeroValue: 0,
    emptyText: '',
    falseValue: false
  }

  const value1 = values.undefinedValue || 'defalut value'  // defalut value
  const value2 = values.nullValue || 'defalut value'  // defalut value
  const value1 = values.zeroValue || 300  // 300
  const value1 = values.emptyText || 'Hello'  // Hello
  const value1 = values.falseValue || true  // true
  ```
what:

  `??`则只会在目标值为`null`和`undefined`时，取默认值。使用babel转化ES5：

  ```js
  const value = values.targetValue ?? 'Hello'

  // 转换后是：
  var _values$targetValue
  const value = (_values$targetValue = values.targetValue) != null ? _values$targetValue : 'Hello'
  ```

how:

```js
  const values = {
    nullValue: null,
    numberValue: 400,
    zeroValue: 0,
    emptyText: '',
    falseValue: false
  }

  const value1 = values.undefinedValue ?? 'defalut value'  // defalut value
  const value2 = values.nullValue ?? 'defalut value'  // defalut value
  const value1 = values.zeroValue ?? 300  // 0
  const value1 = values.emptyText ?? 'Hello'  // ''
  const value1 = values.falseValue ?? true  // false
  ```

## Optional Chaining

why:

```js
const stu = {
    name: 'jack',
    edu: {
        school: 'SS School',
        object: ['math', 'science'],
        teacher: {
            math: ['Tom', 'Lucy']
        }
    }
}

let ScienceTeacher = stu.edu.classRoom.name // Uncaught TypeError: Cannot read property 'name' of undefined

// 增加判断
let ScienceTeacher = stu && stu.edu && stu.edu.classRoom && stu.edu.classRoom.name
```

what:

  `?.`(可选链)可以大幅简化这种写法。使用babel转换：

  ```js
  let obj = {}

  let target1 = obj?.person

  // 转换后：
  let target1 = obj === null || obj === undefined ? void 0 : obj.person
  ```

  ```js
  let obj = {}

  let target1 = obj?.person?.name

  // 转换后：
  var _obj$person

  let target1 = obj === null || obj === undefined ? void 0 : (_obj$person = obj.person) === null || _obj$person === undefined ? void 0 : _obj$person.name
  ```

how: 

```js
const stu = {
    name: 'jack',
    edu: {
        school: 'SS School',
        object: ['math', 'science'],
        teacher: {
            math: ['Tom', 'Lucy']
        }
    }
}

let ScienceTeacher = stu?.edu?.classRoom?.name  ?? 'room1'
```

## String.matchAll

why:

```js
const regexp = /t(e)(st(\d?))/g;
const str = 'test1test2';

str.match(regexp)  // ["test1", "test2"]

while ((match = regexp.exec(str)) !== null) {
  console.log(match)
}
// ["test1", "e", "st1", "1", index: 0, input: "test1test2", groups: undefined]
// ["test2", "e", "st2", "2", index: 5, input: "test1test2", groups: undefined]


let iter = str.matchAll(regexp)
console.log([...iter])
// ["test1", "e", "st1", "1", index: 0, input: "test1test2", groups: undefined]
// ["test2", "e", "st2", "2", index: 5, input: "test1test2", groups: undefined]
```

what:

  `String.matchAll()`方法返回一个iterator，包含了所有匹配正则表达式，正则表达式必须设置了全局模式g，否则会抛出错误。

## globalThis

why:

  js在浏览器中的全局对象是`window`，在Node环境下是`global`，在web workers中是`self`。

what:

  globalThis是在所有平台都可以使用的全局对象。

  ```js
  // in browser
  globalThis.setTimeout === window.setTimeout // true

  // in node
  globalThis.setTimeout === global.setTimeout
  ```

## Moudule Namespace Exports

why:

  ```js
  export { foo, bar } from 'my_module'

  // 等同于
  import{ foo, bar } from 'my_module'
  export { foo, bar }
  ```

  ```js
  export { default } from 'my_module'
  ```

  ```js
  export { foo as default } from 'my_module'

  // 等同于
  import { foo } from 'my_module'
  export default foo
  ```

  ```js
  export { default as bar } from 'my_moudle'
  ```

what:

  ```js
  export * as ns from 'mod'

  // 等同于
  import * from 'mod'
  export {ns}
  ```

## Well defined for-in order

以前不同的引擎对于`for...in`执行顺序的实现不同，导致这一标准一直不能确定，这次不同的引擎就`for...in`循环的迭代顺序达成一致，实现标准化。

## import.meta

// TODO: 在react项目中实验

获取模块的元信息。需要指定type="module"

```js
<script type="module" src="module.js"></script>

// module.js
console.log(import.meta)
```
返回的是一个包含url属性的对象，url是当前模块的绝对路径。这个对象没有原型对象。

参考文章：

[from medium](https://blog.bitsrc.io/es2020-has-been-finalized-here-is-what-im-excited-about-414959bc2f7f)
[from freecodecamp](https://www.freecodecamp.org/news/javascript-new-features-es2020/)
[from dev.to](https://dev.to/carlillo/es2020-features-in-simple-examples-1513)
[MDN对应的知识点]