---
title: ES2020新特性
date: 2020-07-18 09:38:21
tags: Javascript
---

ES2020

<!-- more -->

## BigInt

Why:

目前 JS 中最大的数是`Math.pow(2,53) - 1`，也可以通过`Number.Number.MAX_SAFE_INTEGER`获得，顾名思义，这个数是 js 中可以安全递增的最大整数，超出这个数字之外的计算可能存在精度丢失的问题。

```js
Number.Number.MAX_SAFE_INTEGER + 1 === Number.Number.MAX_SAFE_INTEGER + 2; // true
```

what：

BigInt 是 js 中的一个新的原始数据类型，在超出原来最大数字限制的范围外，也可以安全的进行存储和大数运算。

how:

创建 BigInt 类型数据：

```js
let num = 474384383483n;

let num1 = BigInt(235423424);
let num2 = BigInt("235423424");

typeof num; // "bigint"
typeof num1; // "bigint"

9007199254740991n + 1n === 9007199254740991n + 2n; // false

// 在最大安全数范围内，非严格比较
10n == 10; // true

// bigint和number使用方式一样，但是两者不能混用。
10n / 10n; // 2n
20n / 2; // 报错：Cannot mix bigInt adn other types

// 在最大安全数范围内，bigint可以通过Number()转成number类型。超出范围的丢失会存在精度丢失
Number(100n); // 100

Number(900719925474099267n); // 900719925474099300
```

## Dynamic import

why:

在之前的 js 中，当 import 一个 module 时，无论这个 module 中的方法或变量有没有被用到，这个 module 都会被引入。

```js
import React, { Component } from "react";
import { print } from "./moduleA";

class App extends Component {
  handleClick = () => {
    print("moduleA will always be imported");
  };

  render() {
    return <button onClck={this.handleClick}>click</button>;
  }
}
```

what：

动态加载也可以称之为按需加载，可以理解成是原生的 code-splitting。

how:

import(module)方法可以在任何地方调用，返回一个解析为模块对象的 promise

```js
import React, { Component } from "react";

class App extends Component {
  handleClick = () => {
    import("./moduleA")
      .then((module) => {
        module.print("moduleA will be imported when you click the button");
      })
      .catch((err) => {
        //
      });
  };

  render() {
    return <button onClick={this.handleClick}>click</button>;
  }
}
```

也可以在 if-else 等条件语句中使用。

需要动态import时再用。优先还是使用静态，有利于tree-shaking。

Use dynamic import only when necessary. The static form is preferable for loading initial dependencies, and can benefit more readily from static analysis tools and tree shaking.

[使用动态import的情景](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)

[test link](https://codesandbox.io/s/twilight-bush-0bnt0?file=/src/App.js)

## Promise.allSettled

why:

`Promise.all()`方法返回的 promise 的状态由传入的每个 promise 的状态决定，只要有一个状态是 rejected，则返回的 promise 的状态就是 rejected。

```js
const promiseArray = [
  Promise.resolve("🍕"),
  Promise.reject("🍍"),
  Promise.resolve("🍺"),
  Promise.reject(new Error("Oh No!")),
]
Promise.all(promiseArray)
  .then(data => {
    console.log('all resolved! the values are:' data)
  })
  .catch(err => {
    console.log('be rejectd! error is ', err)
  })

// be rejectd! error is null
```

what:

`Promise.allSettled()`接受一个 promise 的数组作为参数，返回的 promise 状态指挥变成`fulfilled`，无论传入的每个 promise 的是 resolved 还是 rejected。

how:

```js
const promiseArray = [
  Promise.resolve("🍕"),
  Promise.reject("🍍"),
  Promise.resolve("🍺"),
  Promise.reject(new Error("Oh No!")),
];
Promise.allSettled(promiseArray)
  .then((data) => {
    console.log(data);
  })
  .catch((err) => {
    console.log("be rejectd! error is ", err);
  });

// [
//   {status: "fulfilled", value: "🍕"},
//   {status: "rejected", reason: "🍍"},
//   {status: "fulfilled", value: "🍺"},
//   {status: "rejected", reason: Error: Oh No!}
// ]
```

## Nullish Coalescing

why:

通常情况下在获取值的时候我们会设置默认值，防止默认值是 null 或者 undefined。一般使用`||`来实现，但在 ES2020 之前会有个问题，可以转化为`false`的所有值，都会获取默认值。

```js
const values = {
  nullValue: null,
  numberValue: 0,
  stringValue: "",
  booleanValue: false,
};

const value1 = values.dog || "cat"; // cat
const value2 = values.nullValue || "defalut value"; // defalut value
const value3 = values.numberValue || 300; // 300
const value4 = values.stringValue || "Hello"; // Hello
const value5 = values.booleanValue || true; // true
```

what:

`??`则只会在目标值为`null`和`undefined`时，取默认值。使用 babel 转化 ES5：

```js
const value = values.targetValue ?? "Hello";

// 转换后是：
var _values$targetValue;
const value =
  (_values$targetValue = values.targetValue) != null
    ? _values$targetValue
    : "Hello";

// or

const value =
  (_values$targetValue = values.targetValue) !== null &&
  _values$targetValue !== void 0
    ? _values$targetValue
    : "Hello";
```

how:

```js
const values = {
  nullValue: null,
  numberValue: 0,
  stringValue: "",
  booleanValue: false,
};

const value1 = values.dog ?? "cat"; // cat
const value2 = values.nullValue ?? "defalut value"; // defalut value
const value3 = values.numberValue ?? 0; // 0
const value4 = values.stringValue ?? "Hello"; // ""
const value5 = values.booleanValue ?? true; // false
```

## Optional Chaining

why:

```js
const stu = {
  name: "jack",
  edu: {
    school: "SS School",
    object: ["math", "science"],
    teacher: {
      math: ["Tom", "Lucy"],
    },
  },
};

let ScienceTeacher = stu.edu.classRoom.name; // Uncaught TypeError: Cannot read property 'name' of undefined

// 增加判断
let ScienceTeacher =
  stu && stu.edu && stu.edu.classRoom && stu.edu.classRoom.name;
```

what:

`?.`(可选链)可以大幅简化这种写法。使用 babel 转换：

```js
let obj = {};

let target1 = obj?.person;

// 转换后：
let target1 = obj === null || obj === undefined ? void 0 : obj.person;
```

```js
let obj = {};

let target1 = obj?.person?.name;

// 转换后：
var _obj$person;

let target1 =
  obj === null || obj === undefined
    ? void 0
    : (_obj$person = obj.person) === null || _obj$person === undefined
    ? void 0
    : _obj$person.name;
```

how:

```js
const stu = {
  name: "jack",
  edu: {
    school: "SS School",
    object: ["math", "science"],
    teacher: {
      math: ["Tom", "Lucy"],
    },
  },
};

let ScienceTeacher = stu?.edu?.classRoom?.name ?? "room1";
```

`?.`操作符是短路的，即如果它的左边的值为`null`或`undefined`时，右边的代码不会继续执行。

```js
let x = 0;
const a = ["bat", "foo"];

a?.[++x]; //a 不是null或undefined时，x才会计算, 这里返回foo
```

函数调用也可以使用`?.`

```js
const func = (val) => console.log(val);

func?.("foo");
```

## String.matchAll

why:

```js
const regexp = /t(e)(st(\d?))/g;
const str = "test1test2";

str.match(regexp); // ["test1", "test2"]

while ((match = regexp.exec(str)) !== null) {
  console.log(match);
}
// ["test1", "e", "st1", "1", index: 0, input: "test1test2", groups: undefined]
// ["test2", "e", "st2", "2", index: 5, input: "test1test2", groups: undefined]

let iter = str.matchAll(regexp);
console.log([...iter]);
// ["test1", "e", "st1", "1", index: 0, input: "test1test2", groups: undefined]
// ["test2", "e", "st2", "2", index: 5, input: "test1test2", groups: undefined]
```

what:

`String.matchAll()`方法返回一个 iterator，包含了所有匹配正则表达式，正则表达式必须设置了全局模式 g，否则会抛出错误。

## globalThis

why:

js 在浏览器中的全局对象是`window`，在 Node 环境下是`global`，在 web workers 中是`self`。

what:

globalThis 是在所有平台都可以使用的全局对象。

```js
// in browser
globalThis.setTimeout === window.setTimeout; // true

// in node, node版本12.0.0
globalThis.setTimeout === global.setTimeout;
```

## Moudule Namespace Exports

why:

```js
export { foo, bar } from "my_module";

// 等同于
import { foo, bar } from "my_module";
export { foo, bar };
```

```js
export { default } from "my_module";
```

```js
export { foo as default } from "my_module";

// 等同于
import { foo } from "my_module";
export default foo;
```

```js
export { default as bar } from "my_moudle";
```

what:

```js
export * as ns from 'mod'

// 等同于
import * from 'mod'
export {ns}
```

## Well defined for-in order

以前不同的引擎对于`for...in`执行顺序的实现不同，导致这一标准一直不能确定，这次不同的引擎就`for...in`循环的迭代顺序达成一致，实现标准化。

所以 ES2020 不要求统一属性遍历顺序，而是对遍历过程中的一些特殊 Case 明确定义了一些规则：

* 遍历不到 Symbol 类型的属性

* 遍历过程中，目标对象的属性能被删除，忽略掉尚未遍历到却已经被删掉的属性

* 遍历过程中，如果有新增属性，不保证新的属性能被当次遍历处理到

* 属性名不会重复出现（一个属性名最多出现一次）

* 目标对象整条原型链上的属性都能遍历到

## import.meta

获取模块的元信息。需要指定 type="module"

```js
<script type="module" src="module.js"></script>;

// module.js
console.log(import.meta);
```

[test link](https://codesandbox.io/s/musing-haslett-gmhj6?file=/test.js)

返回的是一个包含 url 属性的对象，url 是当前模块的绝对路径。这个对象没有原型对象。

参考文章：

[from medium](https://blog.bitsrc.io/es2020-has-been-finalized-here-is-what-im-excited-about-414959bc2f7f)

[from freecodecamp](https://www.freecodecamp.org/news/javascript-new-features-es2020/)

[from dev.to](https://dev.to/carlillo/es2020-features-in-simple-examples-1513)

[MDN 对应的知识点]
