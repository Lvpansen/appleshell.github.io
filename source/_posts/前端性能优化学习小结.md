---
title: 前端性能优化学习小结
date: 2020-04-04 14:00:32
tags: 性能优化
---

学习掘金小册中的前端性能优化内容，记录知识概要。[学习资源](https://juejin.im/book/5b936540f265da0a9624b04b/section/5b936540f265da0aec223b5d)

<!-- more -->

## 一道面试题

> 从在浏览器中输入 URL 到页面加载完成，发生了什么？

前端的性能优化方面的内容，基本上都以这个问题的答案为骨架展开。

复习一下答案：通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址 → 与这个 IP 地址指向的服务器建立 TCP 网络连接 → 客户端向服务端发出 HTTP 请求 → 服务端处理完请求，将结果放在 HTTP 响应中返回给客户端 → 浏览器渲染拿到的响应数据。如下图

![img1](https://user-gold-cdn.xitu.io/2018/10/18/16685737b823244c?imageslim)

如何理解这个过程和性能优化的关系呢，举例说明：

- DNS 解析花时间，考虑尽量减少解析次数或者把解析前置————浏览器 DNS 缓存和 DNS prefetch；
- TCP 三次握手急死人，怎么办？————长连接、预连接、接入 SPDY 协议；

这两个过程往往需要前端和后端协作完成。前端单方面可做的呢？

- 减少 HTTP 请求次数、减少请求体积
- 服务器越远，请求越慢————部署项目时，将静态资源放在 CDN 上。

以上几点都是网络层面的性能优化，下面是浏览器的性能优化：

- 资源加载优化
- 服务端渲染
- 浏览器缓存机制的应用
- DOM 树的构建
- 网页排版和渲染过程优化
- 回流和重回的考量
- DOM 操作的优化
- ......

完整的知识图谱：
![性能优化图谱](https://user-gold-cdn.xitu.io/2018/10/23/1669f5358f63c0f8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
主要包括网络层面和渲染层面两大方面。

## 网络层面

网络层面主要涉及三个过程：

- DNS 解析
- TCP 连接
- HTTP 请求/响应

前端主要涉及的是 HTTP 连接方面的优化，包括两方面：

- 减少请求次数
- 减少单次请求所花费的时间
  这两个优化点指向的是前端日常开发中常见的操作————资源的压缩和合并。

### Webpack

webpack 是当前最主流的前端构建工具，上面提的优化点可以具体到 webpack 使用的优化。而 webpack 中的优化主要是两个方面：

- webpack 的构建过程太花时间
- webpack 打包的结果体积太大

[学习文章 1：探索 webpack 构建速度提升方法和优化策略](https://segmentfault.com/a/1190000021952886)

> 构建过程提速优化

- 不要让 loader 做太多事情

  以 babel-loader 为例，配置 include 或者 exclude 来避免不必要的转译，例如可以配置不让转译 node_modules 文件夹。

  可以开启缓存，将转译结果缓存至文件系统。例如`loader: 'babel-loader?cacheDirectory=true'`

- 第三方库的处理

  第三方库以 node_modules 为代表，非常庞大。第三方库的优化可以使用[**DllPlugin**](https://webpack.js.org/plugins/dll-plugin/)，拆分 bundles 和提升构建速度。

- 将 loader 的过程由单线程转为多线程

  使用的是 Happypack。还有一个官方推荐的是[thread-loader](https://webpack.js.org/loaders/thread-loader/)。

> 构建结果体积压缩

- 文件结构可视化

  优化前，先分析构建后包的组成情况。使用的插件是[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)

- 拆分资源

  把体积大的包拆分。这点使用的也是**DllPlugin**。

- 删除冗余代码

  典型的应用是`Tree-Shaking`，官方介绍：

  ```
  Tree shaking is a term commonly used in the JavaScript context for dead-code elimination, or more precisely, live-code import. It relies on ES2015 module import/export for the static structure of its module system.
  ```

  `Tree shaking`用来删除无用的代码（dead-code），或者说引入使用的代码（live-code）。基于的是 ES2015 中 import/export 语法。

- 代码压缩

  webpack 从 4.26.0 起将默认的压缩插件从 uglifyjs-webpack-plugin 改成了[teaser-webpack-plugin](https://webpack.js.org/plugins/terser-webpack-plugin/)。原因是前者使用的 uglify-es 已经不再维护，[详见](https://github.com/webpack/webpack/releases?after=v4.26.1)

  可以通过开启`parallel`配置，实现多线程执行。

- 按需加载
  也可称之为异步加载、代码切割，react 文档中的 code-splitting 也是这个意思。其核心内容是`webpack ensure`。

  [官方文档](https://webpack.js.org/api/module-methods/#requireensure)；

  [学习 ensure 文章](https://cnodejs.org/topic/586823335eac96bb04d3e305)；

  [了解 webpack Code Splitting](https://juejin.im/post/5b31ea4bf265da598524b2ac)；

  [React 中 Code-Splitting](https://reactjs.org/docs/code-splitting.html)

  在 output 中配置[chunkFilename](https://webpack.js.org/configuration/output/#outputchunkfilename)，同时项目中的路由使用 ensure 来引入组件进行配合。

  webpack 中[bundle-loader](https://webpack.js.org/loaders/bundle-loader/)也可以实现按需加载

- Gzip

  webpack的Gzip：使用[CompressionWebpackPlugin](https://webpack.js.org/plugins/compression-webpack-plugin/)插件开启

  HTTP的Gzip: 

    ```
    HTTP 压缩是一种内置到网页服务器和网页客户端中以改进传输速度和带宽利用率的方式。在使用 HTTP 压缩的情况下，HTTP 数据在从服务器发送前就已压缩：兼容的浏览器将在下载所需的格式前宣告支持何种方法给服务器；不支持压缩方法的浏览器将下载未经压缩的数据。最常见的压缩方案包括 Gzip 和 Deflate。
    ```

    这是百度百科的解释，简而言之：**HTTP压缩就是以缩小体积为目的，对HTTP内容进行重新编码的过程**

    使用HTTP压缩，服务端在响应头中设置`Content-Encoding: gzip`。注意：在请求头中设置`accept-encoding:gzip`会被Chrome禁止，这是因为Chrome执行的是w3c的标准，w3c禁止了该行为。