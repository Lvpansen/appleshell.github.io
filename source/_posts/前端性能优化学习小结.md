---
title: 前端性能优化学习小结
date: 2020-04-04 14:00:32
tags: 性能优化
---

学习掘金小册中的前端性能优化内容，记录知识概要。[学习资源](https://juejin.im/book/5b936540f265da0a9624b04b/section/5b936540f265da0aec223b5d)

<!-- more -->

## 一道面试题

> 从在浏览器中输入 URL 到页面加载完成，发生了什么？

前端的性能优化方面的内容，基本上都以这个问题的答案为骨架展开。

复习一下答案：通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址 → 与这个 IP 地址指向的服务器建立 TCP 网络连接 → 客户端向服务端发出 HTTP 请求 → 服务端处理完请求，将结果放在 HTTP 响应中返回给客户端 → 浏览器渲染拿到的响应数据。如下图

![img1](https://user-gold-cdn.xitu.io/2018/10/18/16685737b823244c?imageslim)

如何理解这个过程和性能优化的关系呢，举例说明：

- DNS 解析花时间，考虑尽量减少解析次数或者把解析前置————浏览器 DNS 缓存和 DNS prefetch；
- TCP 三次握手急死人，怎么办？————长连接、预连接、接入 SPDY 协议；

这两个过程往往需要前端和后端协作完成。前端单方面可做的呢？

- 减少 HTTP 请求次数、减少请求体积
- 服务器越远，请求越慢————部署项目时，将静态资源放在 CDN 上。

以上几点都是网络层面的性能优化，下面是浏览器的性能优化：

- 资源加载优化
- 服务端渲染
- 浏览器缓存机制的应用
- DOM 树的构建
- 网页排版和渲染过程优化
- 回流和重回的考量
- DOM 操作的优化
- ......

完整的知识图谱：
![性能优化图谱](https://user-gold-cdn.xitu.io/2018/10/23/1669f5358f63c0f8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
主要包括网络层面和渲染层面两大方面。

## 网络层面

网络层面主要涉及三个过程：

- DNS 解析
- TCP 连接
- HTTP 请求/响应

前端主要涉及的是 HTTP 连接方面的优化，包括两方面：

- 减少请求次数
- 减少单次请求所花费的时间
  这两个优化点指向的是前端日常开发中常见的操作————资源的压缩和合并。

### Webpack

webpack 是当前最主流的前端构建工具，上面提的优化点可以具体到 webpack 使用的优化。而 webpack 中的优化主要是两个方面：

- webpack 的构建过程太花时间
- webpack 打包的结果体积太大

[学习文章 1：探索 webpack 构建速度提升方法和优化策略](https://segmentfault.com/a/1190000021952886)

> 构建过程提速优化

- 不要让 loader 做太多事情

  以 babel-loader 为例，配置 include 或者 exclude 来避免不必要的转译，例如可以配置不让转译 node_modules 文件夹。

  可以开启缓存，将转译结果缓存至文件系统。例如`loader: 'babel-loader?cacheDirectory=true'`

- 第三方库的处理

  第三方库以 node_modules 为代表，非常庞大。第三方库的优化可以使用[**DllPlugin**](https://webpack.js.org/plugins/dll-plugin/)，拆分 bundles 和提升构建速度。

- 将 loader 的过程由单线程转为多线程

  使用的是 Happypack。还有一个官方推荐的是[thread-loader](https://webpack.js.org/loaders/thread-loader/)。

> 构建结果体积压缩

- 文件结构可视化

  优化前，先分析构建后包的组成情况。使用的插件是[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)

- 拆分资源

  把体积大的包拆分。这点使用的也是**DllPlugin**。

- 删除冗余代码

  典型的应用是`Tree-Shaking`，官方介绍：

  ```
  Tree shaking is a term commonly used in the JavaScript context for dead-code elimination, or more precisely, live-code import. It relies on ES2015 module import/export for the static structure of its module system.
  ```

  `Tree shaking`用来删除无用的代码（dead-code），或者说引入使用的代码（live-code）。基于的是 ES2015 中 import/export 语法。

- 代码压缩

  webpack 从 4.26.0 起将默认的压缩插件从 uglifyjs-webpack-plugin 改成了[teaser-webpack-plugin](https://webpack.js.org/plugins/terser-webpack-plugin/)。原因是前者使用的 uglify-es 已经不再维护，[详见](https://github.com/webpack/webpack/releases?after=v4.26.1)

  可以通过开启`parallel`配置，实现多线程执行。

- 按需加载
  也可称之为异步加载、代码切割，react 文档中的 code-splitting 也是这个意思。其核心内容是`webpack ensure`。

  [官方文档](https://webpack.js.org/api/module-methods/#requireensure)；

  [学习 ensure 文章](https://cnodejs.org/topic/586823335eac96bb04d3e305)；

  [了解 webpack Code Splitting](https://juejin.im/post/5b31ea4bf265da598524b2ac)；

  [React 中 Code-Splitting](https://reactjs.org/docs/code-splitting.html)

  在 output 中配置[chunkFilename](https://webpack.js.org/configuration/output/#outputchunkfilename)，同时项目中的路由使用 ensure 来引入组件进行配合。

  webpack 中[bundle-loader](https://webpack.js.org/loaders/bundle-loader/)也可以实现按需加载

- Gzip

  webpack的Gzip：使用[CompressionWebpackPlugin](https://webpack.js.org/plugins/compression-webpack-plugin/)插件开启

  HTTP的Gzip: 

    ```
    HTTP 压缩是一种内置到网页服务器和网页客户端中以改进传输速度和带宽利用率的方式。在使用 HTTP 压缩的情况下，HTTP 数据在从服务器发送前就已压缩：兼容的浏览器将在下载所需的格式前宣告支持何种方法给服务器；不支持压缩方法的浏览器将下载未经压缩的数据。最常见的压缩方案包括 Gzip 和 Deflate。
    ```

    这是百度百科的解释，简而言之：**HTTP压缩就是以缩小体积为目的，对HTTP内容进行重新编码的过程**

    使用HTTP压缩，服务端在响应头中设置`Content-Encoding: gzip`。注意：在请求头中设置`accept-encoding:gzip`会被Chrome禁止，这是因为Chrome执行的是w3c的标准，w3c禁止了该行为。

### 图片优化

  图片优化树前端性能优化不可缺少的一个环节。但与其说优化，不如说权衡，因为我们要做的事情就是去压缩图片体积（或一开始就选用体积较小的图片格式）。但这个优化操作，是以牺牲一部分图片成像质量为代价的。因此优化的主要任务是尽可能的去寻求一个质量与性能之间的平衡点。

  简而言之就是在不同的业务场景下使用合适的图片类型，从而达到在压缩图片体积实现优化的同时尽量保证图片质量。

  时下广泛使用的图片格式有JPEG/JPG、PNG、WebP、Base64、SVG等。

  > JPEG/JPG
  
  有损压缩、体积小、加载快、不支持透明

  > PNG-8和PNG-24

  8和24指的是二进制数的位数。8位的PNG最多支持256种颜色，24位的可以呈现约1600万种颜色。

  无损压缩、质量高、体积大、支持透明

  > SVG

  文本文件、体积小、不失真、兼容性好

  > Base64

  文本文件、依赖编码、小图标解决方案

  Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。

  > WebP

  年轻的全能型选手

  集多种图片格式的有点于一身，局限性就是兼容性太差。

### 浏览缓存机制和缓存策略

webpack打包优化和图片选择优化可以理解成是对资源本身的优化，发生在资源请求前。而本节涉及的是资源请求过程的优化。

缓存，简而言之就是一次获取，多次使用，有效减少网络IO的消耗。Chorme对缓存使用的必要性的解释：
  > 通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。

1. 浏览器缓存机制

    浏览器缓存机制包括四个方面，按照获取资源时请求的优先级依次排列如下：

    - Memory Cache
    - Service Worker Cache
    - HTTP Cache
    - Push Cahce

2. HTTP Cache

    HTTP缓存是最主要和最具代表性的缓存策略，是前端需要深刻理解和掌握的性能优化点。

    HTTP缓存分为**强缓存**和**协商缓存**，强缓存优先级高，只有在命中强缓存失败的情况下，才走协商缓存。

    > 强缓存--浏览器独自决定

      强缓存是利用HTTP头中的`Expires`和`Cache-Control`两个字段来控制的。当请求再次发出时，浏览器会根据请求投中的`Expires`和`Cache-Control`判断目标资源是否命中强缓存。若命中就从缓存中获取资源，不再与服务器进行通信。

      命中强缓存的HTTP状态码是200.

      - expires

        expires是个时间戳，表示资源的过期时间。第一次请求时，由服务器在响应头中的设置。此后请求，浏览器会对比本地时间和expires，判断资源是否过期。

        expires的局限性是依赖本地时间。如果本地时间和服务器时间不同步，就可能带来问题。

      - cache-control

        为了解决expires的局限性，HTTP1.1新增了`Cache-Control`字段。Cache-Control可以视作expires的完全替代方案，继续使用expires只是为了向下兼容。

        cache-control的详细取值可查看[MDN介绍](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)

      Expires和Cache-Control同时出现时，Cache-Control的优先级高。

    > 协商缓存--浏览器和服务器合作决定

    协商缓存需要浏览器和服务器进行通信，浏览器向服务器询问缓存的相关信息，进而判断是否重新发起请求，下载完整的响应，或者还是从本地获取缓存的资源。

    如果服务端提示资源未改动（Not Modified），资源会被重定向到浏览器缓存，此时HTTP状态码是304.

    协商缓存的实现是利用`Last-Modified`和`Etag`两个字段。

    - Last-Modified

      Last-Modified是一个时间戳，当启用了协商缓存时，它会在首次请求时随着Response Headers返回：
      ```
      Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT
      ```
      之后每次请求时，都会带上一个If-Modified-Since的时间戳字段，值就是上面响应头中的值。

      服务器会对比这个字段的值和资源最后修改的时间，来判断资源是否发生了变化，进而决定是否返回新的资源。

      Last-Modified有两个局限：

        1. 修改了资源，但资源内容并没有变化，服务器并不知道资源内容是否发生了变化，依然根据最后修改时间进行判断，导致一次完整的请求————不该重新请求，发生了重新请求。
        2. 文件修改速度过快（比如100ms），而If-Modified-Since只能检查以秒为单位的时间变化，导致没有检测到变化————该请求时，没有请求。

    - Etag

      Etag作为Last-Modified的补充，可以解决上述问题。Etag基于资源内容编码，为每个资源生成一个标识字符串。因此可以精确感知资源内容的变化。

      使用方式和Last-Modified类似，也是在响应头中返回
      ```
      ETag: W/"2a3b-1602480f459"
      ```
      发起请求时带上一个If-None-Match字段，值就是上面响应头中返回的值。

      Etag的弊端是其生成过程需要服务器的额外开销，会影响服务器的性能。

    Last-Modified和Etag同时出现时，Etag的优先级高。

    最后放一张chrome官方的缓存策略图，图片来自[这里](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)

    ![缓存策略](https://pic1.zhimg.com/80/v2-9af573cd1971b2e0260ec9f38ef96650_720w.jpg)
3. Memory Cache
  顾名思义，就是内存中的缓存。内存缓存从效率上说是响应速度最快的一种缓存。几乎所有的网络请求资源都会被浏览器自动加入到memory cache中。但因为数量大且浏览器的内存不能无限扩大两个因素，memory cache也是“短命”的，浏览器tab关闭后，该次浏览的memory cache便告失效。

  从memory cache中获取缓存时，浏览器会忽略HTTP头部中例如`max-age=0`,`no-cache`等配置，但是设置了`no-sotre`，那么资源就不会被以任何形式缓存，即便是memory cache。

4. Service Worker

  Service Worker是一种独立于主线程之外的Javascript线程。它给予了我们更加灵活，更加直接的操作方式，也就是说我们可以自己决定缓存那些文件。这个缓存是永久的，不会随着Tab的关闭被清空，除非手动调用API清空。

5. Push Cache

  Push Cache是HTTP2在server push阶段存在的缓存，比较新的知识。

关于浏览器缓存上述简单的罗列一下相关知识点，下面[这篇文章](https://zhuanlan.zhihu.com/p/44789005)也值得细读。它从按照缓存位置和失效策略对缓存进行了分类，很清晰。同时还有一些案例，方便理解。推荐。

### 浏览器存储

1. Cookie

2. Web Storage

3. IndexDB